;           p1q1.asm
;
;           RUN:      Linux
;           ASSEMBLE: nasm -l p1q1.lst -f elf p1q1.asm
;           LINK:     ld -m elf_i386 -o p1q1 p1q1.o
;
;

; Equivalent statements

; Data segment
SECTION .data

; Un-initialized data segment
SECTION .bss

; Code segment
SECTION .text
GLOBAL _function1

_function1:
	push ebp                ; store the base pointer
	mov ebp, esp            ; move the stack pointer to the new base pointer

	mov esi, [ebp + 8]      ; store the first argument as the src pointer
	mov edi, [ebp + 12]     ; store the second argument as the dst pointer

	mov ecx, 0000005Dh      ; 93 decimal
	mov edx, 00000000h      ; clear edx
	mov ax, 00h             ; clear ax

.loop:
	mov al, [esi]           ; move the contents(n - 7) at esi into al
	cbw                     ; expand the byte into a word
	mov bx, ax              ; store the result into bx

	mov al, byte [esi + 1]	; move the contents(n - 6) at esi into al
	cbw                     ; expand the byte into a word
	add bx, ax              ; add the two integers and store it into bx

	mov al, byte [esi + 2]  ; move the contents(n - 5) at esi into al
	cbw                     ; expand the byte into a word
	add bx, ax              ; add the two integers and store it into bx

	mov al, byte [esi + 3]  ; move the contents(n - 4) at esi into al
	cbw                     ; expand the byte into a word
	add bx, ax              ; add the two integers and store it into bx

	mov al, byte [esi + 4]  ; move the contents(n - 3) at esi into al
	cbw                     ; expand the byte into a word
	add bx, ax              ; add the two integers and store it into bx

	mov al, byte [esi + 5]  ; move the contents(n - 2) at esi into al
	cbw                     ; expand the byte into a word
	add bx, ax              ; add the two integers and store it into bx

	mov al, byte [esi + 6]  ; move the contents(n - 1) at esi into al
	cbw                     ; expand the byte into a word
	add bx, ax              ; add the two integers and store it into bx

	mov al, byte [esi + 7]  ; move the contents(n) at esi into al
	cbw                     ; expand the byte into a word
	add ax, bx              ; add the two integers and store it into ax

        mov bx, 08h             ; move the value 8 into bx
	mov dx, 00h             ; clear dx
	idiv bx                 ; signed division of the sum(ax) by 8(bx)
	mov [edi + 14], ax      ; store the result into y[n]

	inc esi                 ; increase 'n' by 1, moving src pointer
	inc edi                 ; matching dst pointer location
	inc edi                 ; matching dst pointer location
	loopnz .loop

	; Return
	pop ebp
	ret
